// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: controllers.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkInsertControllersParams struct {
	Callsign string
	Session  int32
	Position string
}

const getController = `-- name: GetController :one
SELECT id, session, callsign, position, cid, last_seen_euroscope, last_seen_frontend
FROM controllers
WHERE callsign = $1 AND session = $2
`

type GetControllerParams struct {
	Callsign string
	Session  int32
}

func (q *Queries) GetController(ctx context.Context, arg GetControllerParams) (Controller, error) {
	row := q.db.QueryRow(ctx, getController, arg.Callsign, arg.Session)
	var i Controller
	err := row.Scan(
		&i.ID,
		&i.Session,
		&i.Callsign,
		&i.Position,
		&i.Cid,
		&i.LastSeenEuroscope,
		&i.LastSeenFrontend,
	)
	return i, err
}

const getControllerByCid = `-- name: GetControllerByCid :one
SELECT id, session, callsign, position, cid, last_seen_euroscope, last_seen_frontend
FROM controllers
WHERE cid = $1::text LIMIT 1
`

func (q *Queries) GetControllerByCid(ctx context.Context, cid string) (Controller, error) {
	row := q.db.QueryRow(ctx, getControllerByCid, cid)
	var i Controller
	err := row.Scan(
		&i.ID,
		&i.Session,
		&i.Callsign,
		&i.Position,
		&i.Cid,
		&i.LastSeenEuroscope,
		&i.LastSeenFrontend,
	)
	return i, err
}

const getControllers = `-- name: GetControllers :many
SELECT id, session, callsign, position, cid, last_seen_euroscope, last_seen_frontend FROM controllers
WHERE session = $1
`

func (q *Queries) GetControllers(ctx context.Context, session int32) ([]Controller, error) {
	rows, err := q.db.Query(ctx, getControllers, session)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Controller
	for rows.Next() {
		var i Controller
		if err := rows.Scan(
			&i.ID,
			&i.Session,
			&i.Callsign,
			&i.Position,
			&i.Cid,
			&i.LastSeenEuroscope,
			&i.LastSeenFrontend,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertController = `-- name: InsertController :exec
INSERT INTO controllers (callsign, session, position, cid, last_seen_euroscope, last_seen_frontend)
VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertControllerParams struct {
	Callsign          string
	Session           int32
	Position          string
	Cid               pgtype.Text
	LastSeenEuroscope pgtype.Timestamp
	LastSeenFrontend  pgtype.Timestamp
}

func (q *Queries) InsertController(ctx context.Context, arg InsertControllerParams) error {
	_, err := q.db.Exec(ctx, insertController,
		arg.Callsign,
		arg.Session,
		arg.Position,
		arg.Cid,
		arg.LastSeenEuroscope,
		arg.LastSeenFrontend,
	)
	return err
}

const listControllers = `-- name: ListControllers :many
SELECT id, session, callsign, position, cid, last_seen_euroscope, last_seen_frontend
FROM controllers
WHERE session = $1
ORDER BY callsign
`

func (q *Queries) ListControllers(ctx context.Context, session int32) ([]Controller, error) {
	rows, err := q.db.Query(ctx, listControllers, session)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Controller
	for rows.Next() {
		var i Controller
		if err := rows.Scan(
			&i.ID,
			&i.Session,
			&i.Callsign,
			&i.Position,
			&i.Cid,
			&i.LastSeenEuroscope,
			&i.LastSeenFrontend,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeController = `-- name: RemoveController :execrows
DELETE
FROM controllers
WHERE callsign = $1 AND session = $2
`

type RemoveControllerParams struct {
	Callsign string
	Session  int32
}

func (q *Queries) RemoveController(ctx context.Context, arg RemoveControllerParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeController, arg.Callsign, arg.Session)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setControllerCid = `-- name: SetControllerCid :execrows
UPDATE controllers
SET cid = $1
WHERE callsign = $2 AND session = $3
`

type SetControllerCidParams struct {
	Cid      pgtype.Text
	Callsign string
	Session  int32
}

func (q *Queries) SetControllerCid(ctx context.Context, arg SetControllerCidParams) (int64, error) {
	result, err := q.db.Exec(ctx, setControllerCid, arg.Cid, arg.Callsign, arg.Session)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setControllerEuroscopeSeen = `-- name: SetControllerEuroscopeSeen :execrows
UPDATE controllers
SET last_seen_euroscope = $1
WHERE cid = $3::text AND session = $2
`

type SetControllerEuroscopeSeenParams struct {
	LastSeenEuroscope pgtype.Timestamp
	Session           int32
	Cid               string
}

func (q *Queries) SetControllerEuroscopeSeen(ctx context.Context, arg SetControllerEuroscopeSeenParams) (int64, error) {
	result, err := q.db.Exec(ctx, setControllerEuroscopeSeen, arg.LastSeenEuroscope, arg.Session, arg.Cid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setControllerFrontendSeen = `-- name: SetControllerFrontendSeen :execrows
UPDATE controllers
SET last_seen_frontend = $1
WHERE cid = $3::text AND session = $2
`

type SetControllerFrontendSeenParams struct {
	LastSeenFrontend pgtype.Timestamp
	Session          int32
	Cid              string
}

func (q *Queries) SetControllerFrontendSeen(ctx context.Context, arg SetControllerFrontendSeenParams) (int64, error) {
	result, err := q.db.Exec(ctx, setControllerFrontendSeen, arg.LastSeenFrontend, arg.Session, arg.Cid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setControllerPosition = `-- name: SetControllerPosition :execrows
UPDATE controllers
SET position = $1
WHERE callsign = $2 AND session = $3
`

type SetControllerPositionParams struct {
	Position string
	Callsign string
	Session  int32
}

func (q *Queries) SetControllerPosition(ctx context.Context, arg SetControllerPositionParams) (int64, error) {
	result, err := q.db.Exec(ctx, setControllerPosition, arg.Position, arg.Callsign, arg.Session)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
